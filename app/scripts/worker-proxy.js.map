{"version":3,"sources":["../scripts.babel/worker-proxy.js"],"names":[],"mappings":"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","file":"worker-proxy.js","sourcesContent":["/**\n * (c) 2014 Rob Wu <rob@robwu.nl> (https://robwu.nl)\n * License: MIT/X11\n * https://github.com/Rob--W/chrome-api/tree/master/worker_proxy/\n *\n * In a content script within a Chrome extension, Web Workers run in the page's\n * origin. This means that Web Worker packaged with your extension cannot be\n * used in a content script.\n * This limitation has been resolved before by patch-worker.js (available at\n * https://github.com/Rob--W/chrome-api/blob/master/patch-worker/). That patch\n * has some limitations though, mainly due to the fact that the Worker runs at\n * the page's origin.\n * - importScripts does not work.\n * - Origin-specific features such as IndexedDB or the FileSystem API use the\n *   web page's origin instead of the extension's.\n * - Cross-origin XMLHttpRequest is not possible because the extension's\n *   permissions are not available.\n * \n * All of the previous issues are solved with this patch, because it runs\n * the Worker on the extension's origin. The patch has two constraints:\n * - It relies on the creation and availability of an <iframe>. If the page\n *   removes the <iframe>, then all existing Workers are terminated.\n * - Transferable messages must NOT be used until http://crbug.com/334408 is\n *   fixed.\n *\n * This patch requires a background page or event page (used to negotiate an\n * authentication token to make sure that the frame only accept messages from\n * the content script). Further, the worker_proxy.html file must be declared in\n * \"web_accessible_resources\".\n *\n * Here is an example of a manifest file:\n * \n * \"content_scripts\": [{\n *    \"js\": [ \"worker_proxy.js\", ... ],\n *    \"matches\": [ ... ]\n * }],\n * \"background\": {\n *    \"scripts\": [\"worker_proxy.js\", ...]\n *  },\n * \"web_accessible_resources\": [\"worker_proxy.html\"]\n *\n * worker_proxy.html contains:\n * <script src=\"worker_proxy.js\"></script>\n */\n\n/* jshint maxlen:80, browser:true */\n/* globals chrome, console, crypto, ErrorEvent */\n(function() {\n    'use strict';\n    var EXTENSION_ORIGIN = 'chrome-extension://' + chrome.runtime.id;\n    var MSG_GET_TOKEN = 'worker_proxy wants to get communication token';\n\n    if (location.origin == EXTENSION_ORIGIN) {\n        if (chrome.extension.getBackgroundPage &&\n                chrome.extension.getBackgroundPage() === window) {\n            chrome.runtime.onMessage.addListener(backgroundPageMessageHandler);\n        } else {\n            window.addEventListener('message', extensionProxyMessageHandler);\n        }\n    } else {\n        // Inside a content script\n        window.Worker = ContentScriptWorker;\n    }\n\n    // Background page-specific\n    function backgroundPageMessageHandler(message, sender, sendResponse) {\n        if (message === MSG_GET_TOKEN) {\n            sendResponse(getProxyWorkerChannelToken());\n        }\n    }\n\n    var worker_proxy_token;\n    /**\n     * Get the session token used to authenticate messages between the\n     * content script and worker proxy page. This value will change whenever the\n     * background/event page unloads.\n     */\n    function getProxyWorkerChannelToken() {\n        if (!worker_proxy_token) {\n            var buffer = new Uint8Array(100);\n            crypto.getRandomValues(buffer);\n            var random_token = '';\n            for (var i = 0; i < buffer.length; ++i) {\n                random_token += buffer[i].toString(36);\n            }\n            worker_proxy_token = random_token;\n        }\n        return worker_proxy_token;\n    }\n\n    // Worker-proxy specific\n\n    /**\n     * Spawn a worker.\n     *\n     * @param {MessagePort} messagePort  Messages received on this port will be\n     *                                   sent to the Worker and vice versa.\n     * @param {MessagePort} metadataPort  Port used for sending internal data\n     *                                    such as error events.\n     * @param {string} url  URL of Web worker (relative to the location of\n     *                      the HTML file that embeds this script).\n     */\n    function createWorker(messagePort, metadataPort, url) {\n        var worker = new Worker(url);\n        worker.onmessage = function(event) {\n            messagePort.postMessage(event.data);\n        };\n        worker.onerror = function(event) {\n            metadataPort.postMessage({\n                type: 'error',\n                errorDetails: {\n                    message: event.message,\n                    filename: event.filename,\n                    lineno: event.lineno,\n                    colno: event.colno,\n                }\n            });\n        };\n        metadataPort.onmessage = function(event) {\n            if (event.data.type == 'terminate') {\n                worker.terminate();\n                messagePort.close();\n                metadataPort.close();\n            }\n        };\n        messagePort.onmessage = function(event) {\n            worker.postMessage(event.data);\n        };\n        metadataPort.start();\n        messagePort.start();\n    }\n\n    function extensionProxyMessageHandler(event) {\n        if (!event.data || !event.data.channel_token) {\n            return;\n        }\n        chrome.runtime.sendMessage(MSG_GET_TOKEN, function(token) {\n            if (!token || event.data.channel_token !== token) {\n                console.error('Auth failed, refused to create Worker channel.');\n                return;\n            }\n            createWorker(event.ports[0], event.ports[1], event.data.worker_url);\n        });\n    }\n\n    // Content-script specific\n    var proxyFrame;\n    var proxyFrameMessageQueue = [];\n    var proxyFrameReady = false;\n    /**\n     * Post a message to the worker proxy frame.\n     *\n     * @param {object} message  Message to post.\n     * @param {array|undefined} transferable  List of transferable objects.\n     */\n    function postMessageToWorkerProxy(message, transferables) {\n        proxyFrameMessageQueue.push([message, transferables]);\n\n        if (!proxyFrame) {\n            loadFrameAndFlush();\n        } else if (proxyFrameReady) {\n            chrome.runtime.sendMessage(MSG_GET_TOKEN, function(token) {\n                if (typeof token != 'string') {\n                    // This message is different from the message below, because\n                    // failure to get a message for the first time is probably\n                    // caused by a developer error. If the first load succeeded\n                    // and the later token requests fail again, then either of\n                    // the following happened:\n                    // 1. The extension runtime was reloaded (e.g. by an update,\n                    //    or by pressing Ctrl + R at chrome://extensions, or\n                    //    by calling chrome.runtime.reload()) (most likely).\n                    // 2. The extension developer messed with the message\n                    //    handling and the first message only succeeded by\n                    //    coincidence.\n                    // 3. A bug in Chrome was introduced (least likely).\n                    console.warn('Failed to initialize Worker because of a ' +\n                            'missing session token. Is the extension runtime ' +\n                            'still valid?');\n                    return;\n                }\n                flushMessages(token);\n            });\n        } // else wait until proxyFrame.onload fires.\n\n        function loadFrameAndFlush() {\n            proxyFrameReady = false;\n            proxyFrame = document.createElement('iframe');\n            proxyFrame.src = chrome.runtime.getURL('worker_proxy.html');\n            proxyFrame.style.cssText = 'position:fixed!important;' +\n                'top:-99px!important;' +\n                'left:-99px!important;' +\n                'width:2px!important;' +\n                'height:2px!important;' +\n                'border:0!important';\n            proxyFrame.onload = function() {\n                chrome.runtime.sendMessage(MSG_GET_TOKEN, function(token) {\n                    if (typeof token != 'string') {\n                        console.warn(\n                                'Refused to initialize Web Worker because a ' +\n                                'session token could not be negotiated. Make sure' +\n                                'that worker_proxy.js is loaded first in the ' +\n                                'background or event page.');\n                        return;\n                    }\n                    proxyFrameReady = true;\n                    flushMessages(token);\n                });\n            };\n            (document.body || document.documentElement).appendChild(proxyFrame);\n        }\n\n        function flushMessages(token) {\n            var contentWindow = proxyFrame.contentWindow;\n            if (!contentWindow) {\n                // This should NEVER happen. When it happens, try to recover by\n                // creating the frame again, so that new Workers can be created.\n                console.warn('WARNING: The worker proxy frame was removed; ' +\n                        'all previous workers have been terminated. ');\n                loadFrameAndFlush();\n                return;\n            }\n            while (proxyFrameMessageQueue.length) {\n                // data = [message, transferables]\n                var data = proxyFrameMessageQueue.shift();\n                data[0].channel_token = token;\n                contentWindow.postMessage(data[0], EXTENSION_ORIGIN, data[1]);\n            }\n        }\n    }\n\n    function ContentScriptWorker(url) {\n        if (!url) {\n            throw new TypeError('Not enough arguments');\n        }\n        var messageChannel = new MessageChannel();\n        var metadataChannel = new MessageChannel();\n        // MessagePort implements EventTarget, onmessage and postMessage, these\n        // events will be received by the other end and passed to the Worker.\n        var fakeWorker = messageChannel.port1;\n        fakeWorker.terminate = function() {\n            metadataChannel.port1.postMessage({\n                type: 'terminate'\n            });\n        };\n\n        metadataChannel.port1.onmessage = function(event) {\n            if (event.data.type == 'error') {\n                var error = new ErrorEvent('error', event.data.errorDetails);\n                fakeWorker.dispatchEvent(error);\n                if (typeof fakeWorker.onerror == 'function') {\n                    fakeWorker.onerror(error);\n                }\n            }\n        };\n\n        messageChannel.port1.start();\n        metadataChannel.port1.start();\n\n        postMessageToWorkerProxy({\n            worker_url: url\n        }, [\n        messageChannel.port2,\n        metadataChannel.port2\n        ]);\n\n        // Hide the MessagePort methods from the exposed API.\n        fakeWorker.close = fakeWorker.start = undefined;\n        return fakeWorker;\n    }\n})();\n"]}